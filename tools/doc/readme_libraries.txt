
The libraries directory contains the HDL libraries that are reused by the HDL designs.

  libraries/-- Technology independent components
            base/         -- common, diag, diagnostics, dp, mm, sens, tst, uth, ...
            dsp/
            external/     -- easics, numonyx_m25p128, ptp
            io/           -- epcs, i2c, ppsh, mdio, remu, eth, mac_10g, ddr, hmc, ...
            
            -- Mapping to technology dependent vendor IP components
            technology

The technology directory provides the FPGA specific IP as technology independent IP.

  technology/-- FPGA chip vendor IP
             ip_<device_name>/
             ip_stratixiv/
                       .            -- simple single file FPGA IP
                       <ip_name>/   -- composite multi file FPGA IP
             ip_arria10/
             ip_virtex4/
             ip_virtex7/
             
             -- Technology packages
             technology_pkg.vhd         -- technology identifiers and some low level functions
             technology_select_pkg.vhd  -- constant for default device selection 
             
             -- Technology independent IP
             fifo/         -- FIFOs
             flash/        -- access to external flash memory
             iobuf/        -- simple PHY IO pin buffers
             memory/       -- internal FPGA RAM and ROM components
             transceiver/  -- non bonded gigabit transceivers

The device dependend IP is organised per device in the ip_<device_name>/ directories. All files in the IP directories start with prefix
'ip_<device_name>' followed by a component name.

The technology indenpendent components are organised per component type in the <component_type>/ directories (like fifo/ iobuf/ etc). All
files in the technology independent IP directories start with prefix 'tech_<component_type>' followed by a component name.

The technology naming convention nicely clarifies the level of the component. The 'ip_' prefix indicates vendor specific IP and garantuees a name
that will be different from any name that the vendor may use for its components. The 'tech_' prefix indicates the that the component is a wrapper
component that acts as a portal between the technology independent application and the technology dependent IP.

The supported IP technologies are given an indentifier number in the technology_pkg.vhd. The default technology can be selected via the
c_tech_select_default constant in technology_select_pkg.vhd or it can be passed on through the hierarchy via the g_technology generic.

The vendor IP components are typically pregenerated by the MegaWizard in case of Altera and Coregen in case of Xilinx. For each variation of
parameters it may be necessary to pregenerate an IP component. Alternatively for many Altera IP components it is allowed to add generics to
the IP sources to make some parameters configurable without having to run the MegaWizard for each variation.

Each technology independent component directory contains a tech_<component_type>_component_pkg that lists the IP components from the vendor IP directories.
The tech_<component_type>_component_pkg makes all vendor IP known to the synthesis tool, while allowing the synthesis tool to ignore all foreign vendor IP. 
Only the vendor device IP libraries that are realy needed for the selected technology need to be made available for synthesis. Similar for simulation only
the actually used vendor device IP libraries need to be avaiable. However in simulation it is also allowed to make all vendor device IP libraries available.
The 'tech_<component_type><component name>.vhd' technology independent component files have an IP library clause that declares the IP libraries to ensure
default binding in simulation. The IP library clause is ignored by synthesis. E.g. LIBRARY ip_stratixiv_lib, LIBRARY ip_virtex4_lib.
The default component to entity binding works because there is only one entity-architecture implementation for each IP component, because thanks
to the IP naming convention with prefix 'ip_<device_name><component_name>.vhd' all vendor device IP components will have a unique name.

The mapping from technology independent tech_* component to the FPGA technology dependent ip_* components can be seen as a matrix:
- rows: the ip_<device_name>/ contain all different IP components for 1 IP technology (e.g. ip_stratixiv/, ip_arria10/)
- columns: the tech_<component_type>/ contain for each component all IP technologies (e.g. fifo/, memory/, transceiver/, tse/)

   ip_stratixiv -->  ram    fifo   tse    gx           tr_10GbE  ddr3   -
   ip_arria10   -->  ram    fifo   tse    gx           tr_10GbE  ddr3   ddr4
                      |      |      |      |            |         |
                      |      |      |      |            |         |          ... tech_<component_type>_component_pkg packages
                      v      v      v      v            v
                    tech_   tech_  tech_  tech_        tech_      tech_
                    memory  fifo   tse    transceiver  tr_10GbE   ddr        ... tech_<component_type>
                      |      |      |      |            |         |
                      |      |      |      |            |         |
                      v      v      v      v            v         v
                    common/ common/ io/    io/          io/       io/
                            dp/     tse    transceiver  tr_10GbE  io_ddr      ... io_<component_type>
                                                                              ... common_<component_type>
                                                                              ... dp_<component_type>
                                                                              
The tech_<component_type>_component_pkg per 'column' makes the 'column' of all IP specific implementations of the component available to the technology
independent tech_<component_type> file. The components in tech_<component_type>_component_pkg are in generic VHDL. The architecture that belongs to each
is IP dependent, but is not needed if that IP is not selected. In this way each synthesis tool only 'sees' the IP that fits the device that it supports.

On top of the tech_<component_type> level there can be yet another functional level to ease the generic usage of the component in an application. This
extra level typically adds useful default functionality like eg. diagnostic test functionality and FIFOs in case of a PHY IO component. It may also
contain a simulation model for the PHY IO component.

For IP libraries that are instantiated as components in the tech_*.vhd it is necessary to declare these IP libraries to ensure default binding in
simulation, e.g. like in tech_ddr_stratixiv.vhd. This IP library clause is ignored by synthesis, so then the exclusion causes no errors.
